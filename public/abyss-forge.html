<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Abyss Forge | Pattern Lock</title>
    <style>
        body { background: #000; color: #0f0; font-family: 'Courier New', monospace; text-align: center; overflow: hidden; }
        h2 { margin-top: 20px; text-shadow: 0 0 10px #0f0; }
        #canvas-container { position: relative; margin: 20px auto; width: 300px; height: 300px; border: 2px solid #333; box-shadow: 0 0 20px #004400; border-radius: 10px; background: #050505; }
        canvas { touch-action: none; } /* Prevents scrolling while drawing */
        .status { margin-top: 15px; color: #666; font-size: 0.9em; }
        button { background: #003300; color: #fff; border: 1px solid #0f0; padding: 10px 30px; margin-top: 20px; font-size: 1em; cursor: pointer; }
        button:active { background: #0f0; color: #000; }
    </style>
</head>
<body>

    <h2>‚ö° ABYSS FORGE</h2>
    <p>Trace Your Sigil</p>

    <div id="canvas-container">
        <canvas id="forgeCanvas" width="300" height="300"></canvas>
    </div>

    <div class="status" id="status">WAITING FOR INPUT...</div>
    <button onclick="clearCanvas()">RESET</button>

    <script src="router.js"></script>
    <script>
        const canvas = document.getElementById('forgeCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        let isDrawing = false;
        let rawPoints = [];

        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('touchstart', (e) => startDraw(e.touches[0]));
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); });
        canvas.addEventListener('touchend', endDraw);

        function startDraw(e) {
            isDrawing = true;
            rawPoints = []; 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            ctx.moveTo(x, y);
            rawPoints.push({x, y});
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctx.lineTo(x, y);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff00';
            ctx.stroke();

            rawPoints.push({x, y});
        }

        function endDraw() {
            if (!isDrawing) return;
            isDrawing = false;
            status.innerText = "PROCESSING GEOMETRY...";
            
            // ‚ö° MATH PERFECTION STEP: Resample to exactly 50 points (the size of the C++ struct)
            const perfectTrace = normalizeTrace(rawPoints, 50); 
            sendToShield(perfectTrace);
        }

        function normalizeTrace(points, targetCount) {
            if (points.length < 2) return [];

            // Simple linear sampling (takes N evenly spaced points)
            let resampled = [];
            const jump = Math.floor(points.length / targetCount);
            
            for(let i=0; i < targetCount; i++) {
                let index = i * jump;
                if(index >= points.length) index = points.length - 1;
                // We send the X-coordinate only for V1 DTW matching
                resampled.push(Math.floor(points[index].x)); 
            }
            return resampled;
        }

        async function sendToShield(traceData) {
            status.innerText = "SENDING TO ABYSS...";
            
            try {
                // URL: http://192.168.4.1/api/abyss/trace (Shield local IP)
                const response = await fetch('http://192.168.4.1/api/abyss/trace', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ trace: traceData })
                });

                if (response.ok) {
                    status.innerText = "‚úÖ PATTERN SENT. CHECK SERIAL MONITOR FOR RESULT.";
                    status.style.color = "#00ff00";
                } else {
                    status.innerText = "‚ö†Ô∏è REJECTED BY SHIELD.";
                    status.style.color = "orange";
                }
            } catch (e) {
                console.error("Shield communication error:", e);
                status.innerText = "üî¥ ERROR: Connect to Chaos_Shield_Abyss Wi-Fi.";
                status.style.color = "red";
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            status.innerText = "READY.";
            status.style.color = "#666";
        }
    </script>
</body>
</html>
